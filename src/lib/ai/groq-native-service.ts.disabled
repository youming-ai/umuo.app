/**
 * Groq åŸç”Ÿè½¬å½•æœåŠ¡
 * ç›´æ¥ä½¿ç”¨ Groq SDK è€Œä¸æ˜¯ AI SDKï¼Œæ”¯æŒå®Œæ•´çš„ word-timestamps
 */

import Groq from "groq-sdk";
import type { FileRow, TranscriptRow, Segment } from "@/types/db/database";
import GroqFormatConverter, {
  type GroqFullResponse,
} from "@/lib/utils/groq-format-converter";

export interface GroqTranscriptionConfig {
  model?: string;
  language?: string;
  temperature?: number;
  responseFormat?: "json" | "text" | "verbose_json" | "srt" | "vtt";
  timestampGranularities?: Array<"word" | "segment">;
  prompt?: string;
}

export interface GroqTranscriptionResult {
  success: true;
  transcript: TranscriptRow;
  segments: Segment[];
  metadata: {
    processingTime: number;
    audioSize: number;
    model: string;
    language: string;
  };
}

export interface GroqTranscriptionError {
  success: false;
  error: {
    code: string;
    message: string;
    details?: Record<string, unknown>;
  };
}

export class GroqNativeService {
  private static readonly DEFAULT_CONFIG: GroqTranscriptionConfig = {
    model: "whisper-large-v3-turbo",
    language: "ja",
    temperature: 0,
    responseFormat: "verbose_json",
    timestampGranularities: ["word", "segment"],
  };

  /**
   * ç›´æ¥ä½¿ç”¨ Groq API è¿›è¡Œè½¬å½•
   */
  static async transcribe(
    audioFile: File | Blob,
    config: Partial<GroqTranscriptionConfig> = {},
  ): Promise<GroqTranscriptionResult | GroqTranscriptionError> {
    const startTime = Date.now();
    const finalConfig = { ...this.DEFAULT_CONFIG, ...config };

    console.log(`ğŸš€ å¼€å§‹ Groq åŸç”Ÿè½¬å½•:`, {
      fileName: (audioFile as File).name || "unknown",
      fileSize: audioFile.size,
      model: finalConfig.model,
      language: finalConfig.language,
      responseFormat: finalConfig.responseFormat,
      timestampGranularities: finalConfig.timestampGranularities,
    });

    // æ£€æŸ¥ API å¯†é’¥
    const apiKey = process.env.GROQ_API_KEY;
    if (!apiKey) {
      return {
        success: false,
        error: {
          code: "API_KEY_MISSING",
          message: "Groq API å¯†é’¥æœªé…ç½®",
        },
      };
    }

    try {
      // åˆ›å»º Groq å®¢æˆ·ç«¯
      const groq = new Groq({
        apiKey,
      });

      // ä½¿ç”¨ Groq SDK çš„ transcription æ–¹æ³•
      const transcription = await groq.audio.transcriptions.create({
        file: audioFile as File,
        model: (finalConfig.model || "whisper-large-v3-turbo") as any, // ç±»å‹è½¬æ¢
        language: finalConfig.language,
        temperature: finalConfig.temperature,
        response_format: (finalConfig.responseFormat || "verbose_json") as any, // è½¬æ¢ä¸º SDK æœŸæœ›çš„æ ¼å¼
        timestamp_granularities: (finalConfig.timestampGranularities || [
          "segment",
        ]) as any[],
      });

      // æ„å»º Groq å“åº”æ ¼å¼ä»¥åŒ¹é…ç°æœ‰çš„è½¬æ¢å™¨
      const groqResponse: GroqFullResponse = {
        success: true,
        id: `groq-${Date.now()}`,
        object: "transcription",
        created: new Date().toISOString(),
        model: finalConfig.model || "whisper-large-v3-turbo",
        choices: [
          {
            index: 0,
            transcript: transcription.text,
            words: (transcription as any).words || [],
            segments: (transcription as any).segments || [],
            avg_logprob: (transcription as any).avg_logprob,
            compression_ratio: (transcription as any).compression_ratio,
            no_speech_prob: (transcription as any).no_speech_prob,
            temperature: finalConfig.temperature,
          },
        ],
      };

      console.log(`ğŸ“¥ æ”¶åˆ° Groq å“åº”:`, {
        responseId: groqResponse.id,
        model: groqResponse.model,
        hasTranscript: !!groqResponse.choices?.[0]?.transcript,
        segmentCount: groqResponse.choices?.[0]?.segments?.length || 0,
        wordCount: groqResponse.choices?.[0]?.words?.length || 0,
      });

      // éªŒè¯å“åº”æ ¼å¼
      if (!GroqFormatConverter.validateResponse(groqResponse)) {
        return {
          success: false,
          error: {
            code: "INVALID_RESPONSE_FORMAT",
            message: "Groq API è¿”å›äº†æ— æ•ˆçš„å“åº”æ ¼å¼",
            details: { response: groqResponse },
          },
        };
      }

      // è½¬æ¢ä¸ºæ ‡å‡†æ ¼å¼
      const processingTime = Date.now() - startTime;
      const metadata = GroqFormatConverter.extractMetadata(groqResponse);
      const segments =
        GroqFormatConverter.convertToStandardSegments(groqResponse);

      // åˆ›å»º transcript è®°å½•
      const now = new Date();
      const transcript: TranscriptRow = {
        id: 0, // å°†åœ¨æ•°æ®åº“æ“ä½œä¸­è®¾ç½®
        fileId: 0, // å°†åœ¨è°ƒç”¨æ–¹è®¾ç½®
        status: "completed",
        rawText: metadata.rawText || "",
        text: metadata.text || "",
        language: metadata.language || finalConfig.language || "auto",
        duration: metadata.duration || 0,
        processingTime: processingTime / 1000, // è½¬æ¢ä¸ºç§’
        createdAt: metadata.createdAt || now,
        updatedAt: metadata.updatedAt || now,
      };

      // ä¸º segments è®¾ç½® transcriptId
      segments.forEach((segment) => {
        segment.transcriptId = 0; // å°†åœ¨æ•°æ®åº“æ“ä½œä¸­è®¾ç½®
      });

      // è®°å½•è½¬æ¢è¯¦æƒ…
      GroqFormatConverter.logConversionDetails(groqResponse, segments);

      console.log(`âœ… Groq è½¬å½•å®Œæˆ:`, {
        processingTime: processingTime,
        segmentCount: segments.length,
        totalDuration: metadata.duration,
        language: transcript.language,
      });

      return {
        success: true,
        transcript,
        segments,
        metadata: {
          processingTime: processingTime / 1000,
          audioSize: audioFile.size,
          model: groqResponse.model,
          language: transcript.language || "auto",
        },
      };
    } catch (error) {
      const processingTime = Date.now() - startTime;
      console.error(`âŒ Groq è½¬å½•å¤±è´¥ (${processingTime}ms):`, error);

      // å°è¯•è§£æé”™è¯¯ä¿¡æ¯
      let errorCode = "TRANSCRIPTION_ERROR";
      let errorMessage = "è½¬å½•å¤„ç†å¤±è´¥";

      if (error instanceof Error) {
        if (error.message.includes("quota")) {
          errorCode = "QUOTA_EXCEEDED";
          errorMessage = "API é…é¢å·²ç”¨å®Œ";
        } else if (error.message.includes("file too large")) {
          errorCode = "FILE_TOO_LARGE";
          errorMessage = "éŸ³é¢‘æ–‡ä»¶è¿‡å¤§";
        } else if (error.message.includes("unsupported")) {
          errorCode = "UNSUPPORTED_FORMAT";
          errorMessage = "ä¸æ”¯æŒçš„éŸ³é¢‘æ ¼å¼";
        } else if (
          error.message.includes("api key") ||
          error.message.includes("authentication")
        ) {
          errorCode = "INVALID_API_KEY";
          errorMessage = "API å¯†é’¥æ— æ•ˆ";
        } else if (error.message.includes("rate limit")) {
          errorCode = "RATE_LIMIT_EXCEEDED";
          errorMessage = "API è¯·æ±‚è¿‡äºé¢‘ç¹";
        } else {
          errorMessage = error.message;
        }
      }

      return {
        success: false,
        error: {
          code: errorCode,
          message: errorMessage,
          details:
            error instanceof Error
              ? {
                  error: error.message,
                  stack:
                    process.env.NODE_ENV === "development"
                      ? error.stack
                      : undefined,
                  processingTime: processingTime,
                }
              : undefined,
        },
      };
    }
  }

  /**
   * ä¾¿æ·æ–¹æ³•ï¼šä» FileRow è¿›è¡Œè½¬å½•
   */
  static async transcribeFileRow(
    file: FileRow,
    config?: Partial<GroqTranscriptionConfig>,
  ): Promise<GroqTranscriptionResult | GroqTranscriptionError> {
    if (!file.blob) {
      return {
        success: false,
        error: {
          code: "FILE_DATA_MISSING",
          message: "æ–‡ä»¶æ•°æ®ä¸å®Œæ•´ï¼šç¼ºå°‘éŸ³é¢‘æ•°æ®",
        },
      };
    }

    const result = await this.transcribe(file.blob, config);

    // å¦‚æœæˆåŠŸï¼Œè®¾ç½®æ–‡ä»¶ ID
    if (result.success) {
      result.transcript.fileId = file.id!;
      result.segments.forEach((segment) => {
        segment.transcriptId = 0; // å°†åœ¨æ•°æ®åº“æ“ä½œä¸­è®¾ç½®
      });
    }

    return result;
  }

  /**
   * æ‰¹é‡è½¬å½•
   */
  static async transcribeBatch(
    files: FileRow[],
    config?: Partial<GroqTranscriptionConfig>,
    concurrency: number = 2,
  ): Promise<Array<GroqTranscriptionResult | GroqTranscriptionError>> {
    console.log(`ğŸ“¦ å¼€å§‹æ‰¹é‡è½¬å½•:`, {
      fileCount: files.length,
      concurrency,
      model: config?.model || this.DEFAULT_CONFIG.model,
    });

    const results: Array<GroqTranscriptionResult | GroqTranscriptionError> = [];

    // åˆ†æ‰¹å¤„ç†
    for (let i = 0; i < files.length; i += concurrency) {
      const batch = files.slice(i, i + concurrency);
      const batchPromises = batch.map((file) =>
        this.transcribeFileRow(file, config),
      );

      const batchResults = await Promise.allSettled(batchPromises);

      batchResults.forEach((result, index) => {
        if (result.status === "fulfilled") {
          results.push(result.value);
        } else {
          console.error(
            `æ‰¹é‡è½¬å½•å¤±è´¥ - æ–‡ä»¶ ${batch[index].name}:`,
            result.reason,
          );
          results.push({
            success: false,
            error: {
              code: "BATCH_TRANSCRIPTION_ERROR",
              message: "æ‰¹é‡è½¬å½•å¤„ç†å¤±è´¥",
              details: {
                fileName: batch[index].name,
                error:
                  result.reason instanceof Error
                    ? result.reason.message
                    : String(result.reason),
              },
            },
          });
        }
      });
    }

    const successCount = results.filter((r) => r.success).length;
    const failureCount = results.length - successCount;

    console.log(`ğŸ“Š æ‰¹é‡è½¬å½•å®Œæˆ:`, {
      total: results.length,
      success: successCount,
      failure: failureCount,
      successRate: `${((successCount / results.length) * 100).toFixed(1)}%`,
    });

    return results;
  }

  /**
   * æ£€æŸ¥æ¨¡å‹æ˜¯å¦æ”¯æŒ word-timestamps
   */
  static supportsWordTimestamps(model: string): boolean {
    const supportedModels = [
      "whisper-large-v3",
      "whisper-large-v3-turbo",
      "whisper-medium",
      "whisper-large",
    ];

    return supportedModels.some((supportedModel) =>
      model.toLowerCase().includes(supportedModel.toLowerCase()),
    );
  }

  /**
   * è·å–æ¨èçš„é…ç½®
   */
  static getRecommendedConfig(
    language: string = "ja",
    model: string = "whisper-large-v3-turbo",
  ): GroqTranscriptionConfig {
    return {
      model,
      language,
      temperature: 0,
      responseFormat: "verbose_json",
      timestampGranularities: this.supportsWordTimestamps(model)
        ? ["word", "segment"]
        : ["segment"],
    };
  }
}

export default GroqNativeService;
